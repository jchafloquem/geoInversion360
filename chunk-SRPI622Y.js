import{h as x,k as h,l as X,m as A,n as d,o as s,p as S,q as M,v as O,z as E}from"./chunk-ZAQLF7TN.js";import{q as v,s as m}from"./chunk-BRWS572J.js";import{a as C}from"./chunk-AKNRR36C.js";var J=()=>v.getLogger("esri.views.webgl.checkWebGLError");function Q(t,e){switch(e){case t.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case t.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case t.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case t.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case t.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case t.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}var H=!!C("enable-feature:webgl-debug");function L(){return H}function le(){return H}function b(t){if(L()){let e=t.getError();if(e){let r=Q(t,e),o=new Error().stack;J().error(new m("webgl-error","WebGL error occurred",{message:r,stack:o}))}}}var U;(function(t){t[t.Texture=0]="Texture",t[t.RenderBuffer=1]="RenderBuffer"})(U||(U={}));function V(t){switch(t){case x.BYTE:case x.UNSIGNED_BYTE:return 1;case x.SHORT:case x.UNSIGNED_SHORT:case x.HALF_FLOAT:return 2;case x.FLOAT:case x.INT:case x.UNSIGNED_INT:return 4}}function ee(t){let e=t.gl;switch(e.getError()){case e.NO_ERROR:return null;case e.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case e.INVALID_VALUE:return"An unacceptable value has been specified for an argument";case e.INVALID_OPERATION:return"The specified command is not allowed for the current state";case e.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case e.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case e.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function fe(t,e,r,o,i=0){let n=t.gl;t.bindBuffer(r);for(let a of o){let u=e.get(a.name);if(u===void 0){console.warn(`There is no location for vertex attribute '${a.name}' defined.`);continue}let l=i*a.stride;if(a.count<=4)n.vertexAttribPointer(u,a.count,a.type,a.normalized,a.stride,a.offset+l),n.enableVertexAttribArray(u),a.divisor>0&&t.gl.vertexAttribDivisor(u,a.divisor);else if(a.count===9)for(let c=0;c<3;c++)n.vertexAttribPointer(u+c,3,a.type,a.normalized,a.stride,a.offset+12*c+l),n.enableVertexAttribArray(u+c),a.divisor>0&&t.gl.vertexAttribDivisor(u+c,a.divisor);else if(a.count===16)for(let c=0;c<4;c++)n.vertexAttribPointer(u+c,4,a.type,a.normalized,a.stride,a.offset+16*c+l),n.enableVertexAttribArray(u+c),a.divisor>0&&t.gl?.vertexAttribDivisor(u+c,a.divisor);else console.error("Unsupported vertex attribute element count: "+a.count);if(L()){let c=ee(t),_=V(a.type),p=a.offset,T=Math.round(_/p)!==_/p?`. Offset not a multiple of stride. DataType requires ${_} bytes, but descriptor has an offset of ${p}`:"";c&&console.error(`Unable to bind vertex attribute "${a.name}" with baseInstanceOffset ${l}${T}:`,c,a)}}}function W(t){switch(t){case d.ALPHA:case d.LUMINANCE:case d.RED:case d.RED_INTEGER:case s.R8:case s.R8I:case s.R8UI:case s.R8_SNORM:case M.STENCIL_INDEX8:return 1;case d.LUMINANCE_ALPHA:case d.RG:case d.RG_INTEGER:case s.RGBA4:case s.R16F:case s.R16I:case s.R16UI:case s.RG8:case s.RG8I:case s.RG8UI:case s.RG8_SNORM:case s.RGB565:case s.RGB5_A1:case M.DEPTH_COMPONENT16:return 2;case d.DEPTH_COMPONENT:case d.RGB:case d.RGB_INTEGER:case s.RGB8:case s.RGB8I:case s.RGB8UI:case s.RGB8_SNORM:case s.SRGB8:case M.DEPTH_COMPONENT24:return 3;case d.DEPTH_STENCIL:case d.DEPTH24_STENCIL8:case d.RGBA:case d.RGBA_INTEGER:case s.RGBA8:case s.R32F:case s.R11F_G11F_B10F:case s.RG16F:case s.R32I:case s.R32UI:case s.RG16I:case s.RG16UI:case s.RGBA8I:case s.RGBA8UI:case s.RGBA8_SNORM:case s.SRGB8_ALPHA8:case s.RGB9_E5:case s.RGB10_A2UI:case s.RGB10_A2:case M.DEPTH_STENCIL:case M.DEPTH_COMPONENT32F:case M.DEPTH24_STENCIL8:return 4;case M.DEPTH32F_STENCIL8:return 5;case s.RGB16F:case s.RGB16I:case s.RGB16UI:return 6;case s.RG32F:case s.RG32I:case s.RG32UI:case s.RGBA16F:case s.RGBA16I:case s.RGBA16UI:return 8;case s.RGB32F:case s.RGB32I:case s.RGB32UI:return 12;case s.RGBA32F:case s.RGBA32I:case s.RGBA32UI:return 16;case E.COMPRESSED_RGB_S3TC_DXT1_EXT:case E.COMPRESSED_RGBA_S3TC_DXT1_EXT:return .5;case E.COMPRESSED_RGBA_S3TC_DXT3_EXT:case E.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case E.COMPRESSED_R11_EAC:case E.COMPRESSED_SIGNED_R11_EAC:case E.COMPRESSED_RGB8_ETC2:case E.COMPRESSED_SRGB8_ETC2:case E.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case E.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return .5;case E.COMPRESSED_RG11_EAC:case E.COMPRESSED_SIGNED_RG11_EAC:case E.COMPRESSED_RGBA8_ETC2_EAC:case E.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}var w=class{constructor(e=0,r=e){this.width=e,this.height=r,this.target=A.TEXTURE_2D,this.pixelFormat=d.RGBA,this.dataType=S.UNSIGNED_BYTE,this.samplingMode=h.LINEAR,this.wrapMode=X.REPEAT,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.depth=1,this.isImmutable=!1}};function z(t){return t.width<=0||t.height<=0?0:Math.round(t.width*t.height*(t.hasMipmap?4/3:1)*(t.internalFormat==null?4:W(t.internalFormat)))}var G=class t extends w{constructor(e,r){switch(super(),this.context=e,Object.assign(this,r),this.internalFormat){case s.R16F:case s.R16I:case s.R16UI:case s.R32F:case s.R32I:case s.R32UI:case s.R8_SNORM:case s.R8:case s.R8I:case s.R8UI:this.pixelFormat=d.RED}}static validate(e,r){return new t(e,r)}};var Y=4;var te=class g{constructor(e,r=null,o=null){if(this.type=U.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,o=r;else{let i=G.validate(e,r);if(!i)throw new m("Texture descriptor invalid");this._descriptor=i}this._descriptor.target===A.TEXTURE_CUBE_MAP?this._setDataCubeMap(o):this.setData(o)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return z(this._descriptor)}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){this._glName&&this._descriptor.context.instanceCounter.decrement(O.Texture,this),this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,r){let o=this._descriptor;if(o.width!==e||o.height!==r){if(this._wasImmutablyAllocated)throw new m("Immutable textures can't be resized!");o.width=e,o.height=r,this._descriptor.target===A.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(e=null){for(let r=A.TEXTURE_CUBE_MAP_POSITIVE_X;r<=A.TEXTURE_CUBE_MAP_NEGATIVE_Z;r++)this._setData(e,r)}setData(e){this._setData(e)}_setData(e,r){if(!this._descriptor.context?.gl)return;let o=this._descriptor.context.gl;b(o),this._glName||(this._glName=o.createTexture(),this._glName&&this._descriptor.context.instanceCounter.increment(O.Texture,this)),e===void 0&&(e=null);let i=this._descriptor,n=r??i.target,a=N(n);e===null&&(i.width=i.width||Y,i.height=i.height||Y,a&&(i.depth=i.depth??1));let u=this._descriptor.context.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(g.TEXTURE_UNIT_FOR_UPDATES),F(i),this._configurePixelStorage(),b(o);let l=this._deriveInternalFormat();if($(e)){let c="width"in e?e.width:e.codedWidth,_="height"in e?e.height:e.codedHeight,p=1;e instanceof HTMLVideoElement&&(c=e.videoWidth,_=e.videoHeight),i.width&&i.height,a&&i.depth,i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(n,l,i.hasMipmap,c,_,p),this._texImage(n,0,l,c,_,p,e),b(o),i.hasMipmap&&this.generateMipmap(),i.width||(i.width=c),i.height||(i.height=_),a&&!i.depth&&(i.depth=p)}else{let{width:c,height:_,depth:p}=i;if(c==null||_==null)throw new m("Width and height must be specified!");if(a&&p==null)throw new m("Depth must be specified!");if(i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(n,l,i.hasMipmap,c,_,p),y(e)){let T=e.levels,R=j(n,c,_,p),D=Math.min(R-1,T.length-1);o.texParameteri(i.target,this._descriptor.context.gl.TEXTURE_MAX_LEVEL,D);let I=l;if(!ie(I))throw new m("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel((f,P,B,q)=>{let Z=T[Math.min(f,T.length-1)];this._compressedTexImage(n,f,I,P,B,q,Z)},D)}else this._texImage(n,0,l,c,_,p,e),b(o),i.hasMipmap&&this.generateMipmap()}k(o,this._descriptor),K(o,this._descriptor),re(this._descriptor.context,this._descriptor),b(o),this._descriptor.context.bindTexture(u,g.TEXTURE_UNIT_FOR_UPDATES)}updateData(e,r,o,i,n,a,u=0){a||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");let l=this._descriptor,c=this._deriveInternalFormat(),{context:_,pixelFormat:p,dataType:T,target:R,isImmutable:D}=l;if(D&&!this._wasImmutablyAllocated)throw new m("Cannot update immutable texture before allocation!");let I=_.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES,!0);(r<0||o<0||r+i>l.width||o+n>l.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();let{gl:f}=_;u&&f.pixelStorei(f.UNPACK_SKIP_ROWS,u),$(a)?f.texSubImage2D(R,e,r,o,i,n,p,T,a):y(a)?f.compressedTexSubImage2D(R,e,r,o,i,n,c,a.levels[e]):f.texSubImage2D(R,e,r,o,i,n,p,T,a),u&&f.pixelStorei(f.UNPACK_SKIP_ROWS,0),_.bindTexture(I,g.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(e,r,o,i,n,a,u,l){l||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");let c=this._descriptor,_=this._deriveInternalFormat(),{context:p,pixelFormat:T,dataType:R,isImmutable:D,target:I}=c;if(D&&!this._wasImmutablyAllocated)throw new m("Cannot update immutable texture before allocation!");N(I)||console.warn("Attempting to set 3D texture data on a non-3D texture");let f=p.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES);p.setActiveTexture(g.TEXTURE_UNIT_FOR_UPDATES),(r<0||o<0||i<0||r+n>c.width||o+a>c.height||i+u>c.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();let{gl:P}=p;if(y(l))l=l.levels[e],P.compressedTexSubImage3D(I,e,r,o,i,n,a,u,_,l);else{let B=l;P.texSubImage3D(I,e,r,o,i,n,a,u,T,R,B)}p.bindTexture(f,g.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){let e=this._descriptor;if(!e.hasMipmap){if(this._wasImmutablyAllocated)throw new m("Cannot add mipmaps to immutable texture after allocation");e.hasMipmap=!0,this._samplingModeDirty=!0,F(e)}e.samplingMode===h.LINEAR?(this._samplingModeDirty=!0,e.samplingMode=h.LINEAR_MIPMAP_NEAREST):e.samplingMode===h.NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=h.NEAREST_MIPMAP_NEAREST);let r=this._descriptor.context.bindTexture(this,g.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(g.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(e.target),this._descriptor.context.bindTexture(r,g.TEXTURE_UNIT_FOR_UPDATES)}clearMipmap(){let e=this._descriptor;if(e.hasMipmap){if(this._wasImmutablyAllocated)throw new m("Cannot delete mipmaps to immutable texture after allocation");e.hasMipmap=!1,this._samplingModeDirty=!0,F(e)}e.samplingMode===h.LINEAR_MIPMAP_NEAREST?(this._samplingModeDirty=!0,e.samplingMode=h.LINEAR):e.samplingMode===h.NEAREST_MIPMAP_NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=h.NEAREST)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,F(this._descriptor),this._wrapModeDirty=!0)}applyChanges(){let e=this._descriptor,r=e.context.gl;this._samplingModeDirty&&(k(r,e),this._samplingModeDirty=!1),this._wrapModeDirty&&(K(r,e),this._wrapModeDirty=!1)}_deriveInternalFormat(){if(this._descriptor.internalFormat!=null)return this._descriptor.internalFormat===d.DEPTH_STENCIL&&(this._descriptor.internalFormat=d.DEPTH24_STENCIL8),this._descriptor.internalFormat;switch(this._descriptor.dataType){case S.FLOAT:switch(this._descriptor.pixelFormat){case d.RGBA:return this._descriptor.internalFormat=s.RGBA32F;case d.RGB:return this._descriptor.internalFormat=s.RGB32F;default:throw new m("Unable to derive format")}case S.UNSIGNED_BYTE:switch(this._descriptor.pixelFormat){case d.RGBA:return this._descriptor.internalFormat=s.RGBA8;case d.RGB:return this._descriptor.internalFormat=s.RGB8}}return this._descriptor.internalFormat=this._descriptor.pixelFormat===d.DEPTH_STENCIL?d.DEPTH24_STENCIL8:this._descriptor.pixelFormat}_configurePixelStorage(){let e=this._descriptor.context.gl,{unpackAlignment:r,flipped:o,preMultiplyAlpha:i}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,r),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,o?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i?1:0)}_texStorage(e,r,o,i,n,a){let{gl:u}=this._descriptor.context;if(!se(r))throw new m("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;let l=o?j(e,i,n,a):1;if(N(e)){if(a==null)throw new m("Missing depth dimension for 3D texture upload");u.texStorage3D(e,l,r,i,n,a)}else u.texStorage2D(e,l,r,i,n);this._wasImmutablyAllocated=!0}_texImage(e,r,o,i,n,a,u){let l=this._descriptor.context.gl,c=N(e),{isImmutable:_,pixelFormat:p,dataType:T}=this._descriptor;if(_){if(u!=null){let R=u;if(c){if(a==null)throw new m("Missing depth dimension for 3D texture upload");l.texSubImage3D(e,r,0,0,0,i,n,a,p,T,R)}else l.texSubImage2D(e,r,0,0,i,n,p,T,R)}}else{let R=u;if(c){if(a==null)throw new m("Missing depth dimension for 3D texture upload");l.texImage3D(e,r,o,i,n,a,0,p,T,R)}else l.texImage2D(e,r,o,i,n,0,p,T,R)}}_compressedTexImage(e,r,o,i,n,a,u){let l=this._descriptor.context.gl,c=N(e);if(this._descriptor.isImmutable){if(u!=null)if(c){if(a==null)throw new m("Missing depth dimension for 3D texture upload");l.compressedTexSubImage3D(e,r,0,0,0,i,n,a,o,u)}else l.compressedTexSubImage2D(e,r,0,0,i,n,o,u)}else if(c){if(a==null)throw new m("Missing depth dimension for 3D texture upload");l.compressedTexImage3D(e,r,o,i,n,a,0,u)}else l.compressedTexImage2D(e,r,o,i,n,0,u)}_forEachMipmapLevel(e,r=1/0){let{width:o,height:i,depth:n,hasMipmap:a,target:u}=this._descriptor,l=u===A.TEXTURE_3D;if(o==null||i==null||l&&n==null)throw new m("Missing texture dimensions for mipmap calculation");for(let c=0;e(c,o,i,n),a&&(o!==1||i!==1||l&&n!==1)&&!(c>=r);++c)o=Math.max(1,o>>1),i=Math.max(1,i>>1),l&&(n=Math.max(1,n>>1))}};function F(t){(t.width!=null&&t.width<0||t.height!=null&&t.height<0||t.depth!=null&&t.depth<0)&&console.error("Negative dimension parameters are not allowed!")}function k(t,e){let r=e.samplingMode,o=e.samplingMode;r===h.LINEAR_MIPMAP_NEAREST||r===h.LINEAR_MIPMAP_LINEAR?(r=h.LINEAR,e.hasMipmap||(o=h.LINEAR)):r!==h.NEAREST_MIPMAP_NEAREST&&r!==h.NEAREST_MIPMAP_LINEAR||(r=h.NEAREST,e.hasMipmap||(o=h.NEAREST)),t.texParameteri(e.target,t.TEXTURE_MAG_FILTER,r),t.texParameteri(e.target,t.TEXTURE_MIN_FILTER,o)}function K(t,e){typeof e.wrapMode=="number"?(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode)):(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode.s),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode.t))}function re(t,e){let r=t.capabilities.textureFilterAnisotropic;r&&t.gl.texParameterf(e.target,r.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}function se(t){return t in s}function ie(t){return t in E}function y(t){return t!=null&&"type"in t&&t.type==="compressed"}function ae(t){return t!=null&&"byteLength"in t}function $(t){return t!=null&&!y(t)&&!ae(t)}function N(t){return t===A.TEXTURE_3D||t===A.TEXTURE_2D_ARRAY}function j(t,e,r,o=1){let i=Math.max(e,r);return t===A.TEXTURE_3D&&(i=Math.max(i,o)),Math.round(Math.log(i)/Math.LN2)+1}te.TEXTURE_UNIT_FOR_UPDATES=0;export{L as a,le as b,b as c,U as d,V as e,ee as f,fe as g,W as h,w as i,te as j};
